<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>탈모 이미지 일괄 분류기</title>
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: #333;
            text-align: center;
        }
        .section {
            margin-bottom: 30px;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .upload-area {
            border: 2px dashed #ccc;
            padding: 40px 20px;
            text-align: center;
            margin: 20px 0;
            border-radius: 5px;
            background-color: #f9f9f9;
            cursor: pointer;
            transition: all 0.3s;
        }
        .upload-area:hover {
            border-color: #888;
            background-color: #f0f0f0;
        }
        .button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 0;
            transition: background-color 0.3s;
        }
        .button:hover {
            background-color: #3e8e41;
        }
        .button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        input[type="file"] {
            display: none;
        }
        .status {
            text-align: center;
            margin: 10px 0;
            font-weight: bold;
            min-height: 20px;
        }
        .progress {
            width: 100%;
            height: 20px;
            background-color: #f1f1f1;
            border-radius: 5px;
            margin: 10px 0;
        }
        .progress-bar {
            height: 100%;
            background-color: #4CAF50;
            border-radius: 5px;
            width: 0%;
            transition: width 0.3s;
        }
        .results {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
        }
        .category {
            flex: 1;
            min-width: 300px;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            background-color: #f9f9f9;
        }
        .category h3 {
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
            font-size: 18px;
        }
        .category-stats {
            font-weight: bold;
            color: #555;
            margin-bottom: 10px;
        }
        .category-images {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        .image-item {
            position: relative;
            width: 80px;
            height: 80px;
            margin-bottom: 15px;
        }
        .image-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        .image-confidence {
            position: absolute;
            bottom: -15px;
            left: 0;
            right: 0;
            font-size: 10px;
            text-align: center;
            color: #333;
        }
        .settings {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }
        .setting {
            flex: 1;
            min-width: 200px;
        }
        .instructions {
            line-height: 1.6;
        }
        .instructions ol {
            padding-left: 20px;
        }
        .instructions li {
            margin-bottom: 10px;
        }
        .error {
            color: #d32f2f;
            background-color: #ffebee;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border-left: 4px solid #d32f2f;
        }
        .success {
            color: #388e3c;
            background-color: #e8f5e9;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border-left: 4px solid #388e3c;
        }
        .save-button {
            background-color: #2196F3;
        }
        .save-button:hover {
            background-color: #0b7dda;
        }
        #modelPathDisplay {
            word-break: break-all;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
            margin: 10px 0;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>탈모 이미지 일괄 분류기</h1>
        
        <div class="section">
            <h2>1. 모델 로드</h2>
            <div class="instructions">
                <p>Teachable Machine에서 내보낸 모델을 로드하세요:</p>
                <ol>
                    <li>Teachable Machine에서 <strong>'내보내기'</strong> → <strong>'다운로드'</strong> → <strong>'웹모델'</strong> 선택</li>
                    <li><strong>'다운로드 내 모델'</strong> 버튼을 클릭하여 모델 파일 다운로드</li>
                    <li>다운로드된 ZIP 파일 압축 풀기</li>
                    <li>아래 '모델 폴더 선택' 버튼을 클릭하여 압축 푼 폴더 선택 (model.json 파일이 있는 폴더)</li>
                </ol>
            </div>
            
            <label for="modelInput" class="button">모델 폴더 선택</label>
            <input type="file" id="modelInput" webkitdirectory directory>
            
            <div id="modelPathDisplay">모델이 선택되지 않았습니다</div>
            <div id="modelStatus" class="status"></div>
            
            <button id="loadModelBtn" class="button" disabled>모델 로드</button>
        </div>
        
        <div class="section">
            <h2>2. 이미지 분류 설정</h2>
            <div class="settings">
                <div class="setting">
                    <label for="confidenceThreshold">신뢰도 임계값:</label>
                    <input type="range" id="confidenceThreshold" min="0" max="1" step="0.05" value="0.5">
                    <span id="confidenceValue">0.5</span>
                    <p>낮은 신뢰도의 이미지는 '불확실' 카테고리로 분류됩니다</p>
                </div>
            </div>
            
            <div class="upload-area" id="uploadArea">
                <p>이미지를 여기에 드래그하거나 클릭하여 업로드하세요</p>
                <p>여러 이미지를 한 번에 선택할 수 있습니다</p>
            </div>
            <input type="file" id="imageInput" multiple accept="image/*">
            
            <div id="uploadStatus" class="status"></div>
            <div class="progress">
                <div id="progressBar" class="progress-bar"></div>
            </div>
            <button id="classifyBtn" class="button" disabled>이미지 분류 시작</button>
        </div>
        
        <div class="section">
            <h2>3. 분류 결과</h2>
            <div id="resultsArea" class="results">
                <!-- 결과가 여기에 표시됩니다 -->
            </div>
            <div id="saveBtnArea" style="display: none; margin-top: 20px; text-align: center;">
                <button id="saveResultBtn" class="button save-button">결과를 CSV 파일로 저장</button>
            </div>
        </div>
    </div>

    <!-- TensorFlow.js 라이브러리 -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.9.0/dist/tf.min.js"></script>
    
    <script>
        // 전역 변수
        let model;
        let labels = [];
        let selectedImages = [];
        let classifiedImages = {};
        let modelPath = '';
        
        // DOM 요소
        const modelInput = document.getElementById('modelInput');
        const modelPathDisplay = document.getElementById('modelPathDisplay');
        const modelStatus = document.getElementById('modelStatus');
        const loadModelBtn = document.getElementById('loadModelBtn');
        const uploadArea = document.getElementById('uploadArea');
        const imageInput = document.getElementById('imageInput');
        const uploadStatus = document.getElementById('uploadStatus');
        const progressBar = document.getElementById('progressBar');
        const classifyBtn = document.getElementById('classifyBtn');
        const resultsArea = document.getElementById('resultsArea');
        const confidenceThreshold = document.getElementById('confidenceThreshold');
        const confidenceValue = document.getElementById('confidenceValue');
        const saveBtnArea = document.getElementById('saveBtnArea');
        const saveResultBtn = document.getElementById('saveResultBtn');
        
        // 슬라이더 값 표시
        confidenceThreshold.addEventListener('input', function() {
            confidenceValue.textContent = this.value;
        });
        
        // 모델 폴더 선택
        modelInput.addEventListener('change', function(e) {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;
            
            // model.json 파일 찾기
            const modelJsonFile = files.find(file => file.name === 'model.json');
            if (!modelJsonFile) {
                showError("선택한 폴더에 model.json 파일이 없습니다. 올바른 모델 폴더를 선택하세요.");
                return;
            }
            
            // 메타데이터 파일 찾기
            const metadataFile = files.find(file => file.name === 'metadata.json');
            if (!metadataFile) {
                showError("선택한 폴더에 metadata.json 파일이 없습니다. 올바른 모델 폴더를 선택하세요.");
                return;
            }
            
            // model.json 파일 경로 구성
            const folderPath = modelJsonFile.webkitRelativePath.split('/').slice(0, -1).join('/');
            modelPath = folderPath;
            modelPathDisplay.textContent = `선택된 모델 폴더: ${folderPath}`;
            
            // 메타데이터 파일 읽기
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const metadata = JSON.parse(e.target.result);
                    labels = metadata.labels || [];
                    
                    if (labels.length > 0) {
                        loadModelBtn.disabled = false;
                        modelStatus.textContent = `${labels.length}개의 클래스가 발견되었습니다: ${labels.join(', ')}`;
                        modelStatus.className = 'status success';
                    } else {
                        showError("메타데이터 파일에 레이블 정보가 없습니다.");
                    }
                } catch (error) {
                    showError(`메타데이터 파일 파싱 오류: ${error.message}`);
                }
            };
            reader.readAsText(metadataFile);
        });
        
        // 모델 로드
        loadModelBtn.addEventListener('click', async function() {
            try {
                modelStatus.textContent = "모델 로드 중...";
                modelStatus.className = 'status';
                loadModelBtn.disabled = true;
                
                // 각 파일을 가상 파일 시스템에 저장하기 위한 객체 생성
                const modelFiles = {};
                const files = Array.from(modelInput.files);
                const modelFolderPath = modelPath;
                
                // 모델 관련 파일을 객체에 매핑
                for (const file of files) {
                    const filePath = file.webkitRelativePath;
                    if (filePath.startsWith(modelFolderPath)) {
                        const relativePath = filePath.substring(modelFolderPath.length + 1);
                        
                        const reader = new FileReader();
                        const fileContentPromise = new Promise(resolve => {
                            reader.onload = e => resolve(e.target.result);
                        });
                        
                        reader.readAsArrayBuffer(file);
                        const content = await fileContentPromise;
                        
                        modelFiles[relativePath] = content;
                    }
                }
                
                // TensorFlow.js 모델 로드 핸들러 생성
                const modelJsonFile = files.find(file => file.name === 'model.json' && file.webkitRelativePath.startsWith(modelFolderPath));
                if (!modelJsonFile) {
                    throw new Error("model.json 파일을 찾을 수 없습니다.");
                }
                
                const modelJsonReader = new FileReader();
                const modelJsonPromise = new Promise(resolve => {
                    modelJsonReader.onload = e => resolve(e.target.result);
                });
                
                modelJsonReader.readAsText(modelJsonFile);
                const modelJson = JSON.parse(await modelJsonPromise);
                
                // 파일 로드 핸들러 정의
                const loadHandler = {
                    load: async (url) => {
                        if (url === 'model.json') {
                            return modelJson;
                        }
                        
                        const buffer = modelFiles[url];
                        if (!buffer) {
                            throw new Error(`파일을 찾을 수 없습니다: ${url}`);
                        }
                        
                        return new Response(new Blob([buffer]));
                    }
                };
                
                // TensorFlow.js 모델 로드
                model = await tf.loadLayersModel(tf.io.browserFiles([modelJsonFile]));
                
                modelStatus.textContent = "모델 로드 완료! 이제 이미지를 선택하세요.";
                modelStatus.className = 'status success';
                classifyBtn.disabled = true;
                
                // 결과 영역 초기화
                initializeResultsArea();
                
            } catch (error) {
                showError(`모델 로드 오류: ${error.message}`);
                loadModelBtn.disabled = false;
            }
        });
        
        // 이미지 업로드 영역 설정
        uploadArea.addEventListener('click', () => {
            imageInput.click();
        });
        
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.style.borderColor = '#4CAF50';
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.style.borderColor = '#ccc';
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.style.borderColor = '#ccc';
            handleImageFiles(e.dataTransfer.files);
        });
        
        // 이미지 선택 처리
        imageInput.addEventListener('change', (e) => {
            handleImageFiles(e.target.files);
        });
        
        // 이미지 파일 처리
        function handleImageFiles(files) {
            if (!model) {
                showError("먼저 모델을 로드해주세요.");
                return;
            }
            
            selectedImages = Array.from(files).filter(file => file.type.startsWith('image/'));
            
            if (selectedImages.length === 0) {
                uploadStatus.textContent = "선택된 이미지가 없습니다.";
                classifyBtn.disabled = true;
                return;
            }
            
            uploadStatus.textContent = `${selectedImages.length}개의 이미지가 선택되었습니다. '이미지 분류 시작' 버튼을 클릭하세요.`;
            uploadStatus.className = 'status success';
            classifyBtn.disabled = false;
        }
        
        // 결과 영역 초기화
        function initializeResultsArea() {
            resultsArea.innerHTML = '';
            
            // 각 클래스별 결과 영역 생성
            for (const label of labels) {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'category';
                categoryDiv.innerHTML = `
                    <h3>${label}</h3>
                    <div class="category-stats" id="stats-${label}">0개 이미지</div>
                    <div id="category-${label}" class="category-images"></div>
                `;
                resultsArea.appendChild(categoryDiv);
                
                // 결과 객체 초기화
                classifiedImages[label] = [];
            }
            
            // 불확실한 이미지를 위한 카테고리 추가
            const uncertainDiv = document.createElement('div');
            uncertainDiv.className = 'category';
            uncertainDiv.innerHTML = `
                <h3>불확실</h3>
                <div class="category-stats" id="stats-uncertain">0개 이미지</div>
                <div id="category-uncertain" class="category-images"></div>
            `;
            resultsArea.appendChild(uncertainDiv);
            classifiedImages['uncertain'] = [];
        }
        
        // 이미지 분류 시작
        classifyBtn.addEventListener('click', async function() {
            if (!model || selectedImages.length === 0) return;
            
            classifyBtn.disabled = true;
            uploadStatus.textContent = "이미지 분류 중...";
            progressBar.style.width = '0%';
            
            // 결과 초기화
            for (const label of [...labels, 'uncertain']) {
                classifiedImages[label] = [];
                document.getElementById(`category-${label}`).innerHTML = '';
                document.getElementById(`stats-${label}`).textContent = '0개 이미지';
            }
            
            // 각 이미지 분류
            const threshold = parseFloat(confidenceThreshold.value);
            let processedCount = 0;
            
            for (const imageFile of selectedImages) {
                try {
                    // 이미지 로드 및 전처리
                    const img = await loadImage(imageFile);
                    const tensorImg = preprocessImage(img);
                    
                    // 예측
                    const predictions = await model.predict(tensorImg).data();
                    
                    // 최고 확률 클래스 찾기
                    let maxProbIndex = 0;
                    let maxProb = 0;
                    
                    for (let i = 0; i < predictions.length; i++) {
                        if (predictions[i] > maxProb) {
                            maxProb = predictions[i];
                            maxProbIndex = i;
                        }
                    }
                    
                    // 예측 결과 저장
                    const predictedClass = maxProb >= threshold ? labels[maxProbIndex] : 'uncertain';
                    classifiedImages[predictedClass].push({
                        file: imageFile,
                        confidence: maxProb,
                        predictions: Array.from(predictions).map((prob, i) => ({
                            label: labels[i],
                            probability: prob
                        }))
                    });
                    
                    // 결과 표시
                    const imgElement = document.createElement('div');
                    imgElement.className = 'image-item';
                    
                    // 이미지 URL 생성
                    const imageUrl = URL.createObjectURL(imageFile);
                    
                    imgElement.innerHTML = `
                        <img src="${imageUrl}" title="${imageFile.name}">
                        <div class="image-confidence">${(maxProb * 100).toFixed(0)}%</div>
                    `;
                    
                    document.getElementById(`category-${predictedClass}`).appendChild(imgElement);
                    
                    // 통계 업데이트
                    document.getElementById(`stats-${predictedClass}`).textContent = 
                        `${classifiedImages[predictedClass].length}개 이미지`;
                    
                    // 진행 상태 업데이트
                    processedCount++;
                    const progress = (processedCount / selectedImages.length) * 100;
                    progressBar.style.width = `${progress}%`;
                    uploadStatus.textContent = `이미지 분류 중... (${processedCount}/${selectedImages.length})`;
                    
                } catch (error) {
                    console.error(`이미지 처리 오류: ${error.message}`, imageFile);
                    processedCount++;
                }
            }
            
            // 분류 완료
            uploadStatus.textContent = `${selectedImages.length}개의 이미지 분류 완료!`;
            uploadStatus.className = 'status success';
            classifyBtn.disabled = false;
            saveBtnArea.style.display = 'block';
        });
        
        // CSV 파일로 결과 저장
        saveResultBtn.addEventListener('click', function() {
            // CSV 헤더 생성
            let csvContent = "파일명,분류 결과,신뢰도";
            
            // 모든 클래스에 대한 예측값 추가
            for (const label of labels) {
                csvContent += `,${label}`;
            }
            csvContent += "\n";
            
            // 모든 분류된 이미지에 대한 결과 추가
            for (const category in classifiedImages) {
                for (const item of classifiedImages[category]) {
                    let row = `"${item.file.name}","${category}",${item.confidence.toFixed(4)}`;
                    
                    // 각 클래스에 대한 확률 추가
                    for (const prediction of item.predictions) {
                        row += `,${prediction.probability.toFixed(4)}`;
                    }
                    
                    csvContent += row + "\n";
                }
            }
            
            // CSV 파일 다운로드
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', `탈모_분류_결과_${new Date().toISOString().slice(0,10)}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });
        
        // 이미지 로드 함수
        function loadImage(file) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = (e) => reject(new Error('이미지 로드 실패'));
                img.src = URL.createObjectURL(file);
            });
        }
        
        // 이미지 전처리 함수
        function preprocessImage(img) {
            // 캔버스에 이미지 그리기
            const canvas = document.createElement('canvas');
            canvas.width = 224;
            canvas.height = 224;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, 224, 224);
            
            // 이미지 데이터 가져오기
            const imageData = ctx.getImageData(0, 0, 224, 224);
            
            // 텐서로 변환
            const tensor = tf.browser.fromPixels(imageData)
                .expandDims(0)     // 배치 차원 추가
                .toFloat()
                .div(tf.scalar(255)); // 정규화
                
            return tensor;
        }
        
        // 오류 표시 함수
        function showError(message) {
            modelStatus.textContent = message;
            modelStatus.className = 'status error';
        }
    </script>
</body>
</html>
